<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta name="robots" content="noindex">
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>&lt;h1&gt;Introduction&lt;/h1&gt;</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.14 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><h1>Introduction</h1>
</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><br />
 inexlib_py is the collection of exlib examples related to Python put in a standalone package.</p>
<p>The 1.1.x contains examples coworking with Spark. It can be built with Python3. The 1.2.x contains examples that have a "client" mode so that they can send scene graphs to the inexlib_serv application.</p>
<h1><a class="anchor" id="inexlib_py_examples"></a>
Examples</h1>
<p>There are C++ little applications that activate Python through it's library and a set of .py scripts that demonstrate how to activate inlib/exlib from a Python prompt by using the SWIG modules: </p><pre class="fragment">     inlib_swig_py.so            # pure inlib.
     exlib_window_swig_py.so     # on screen inlib/exlib graphics and plotting.
     exlib_offscreen_swig_py.so  # offscreen inlib/exlib graphics and plotting.
</pre><p> These modules has been done by using the SWIG wrapping of some (but not all) classes of inlib and exlib.</p>
<p>C++ apps (source code in inexlib_py/inexlib/exlib/examples/cpp): </p><pre class="fragment">    hello_py.cpp            # to check Python activation from C++.
    h1d_spy.cpp             # inlib histogram wrapped with swig.
    plotter_spy_screen.cpp  # exlib plotting wrapped with swig.
    mandel_py.cpp           # check calling a C++ function from Python.
</pre><p> C++ inlib "client" apps (source code in inexlib_py/inexlib/inlib/examples/cpp): </p><pre class="fragment">    cube_to_sg_serv.cpp     # send a cube to inexlib_serv.
    lego_to_sg_serv.cpp     # send a lego plot to inexlib_serv.
</pre><p> Python .py scripts: </p><pre class="fragment">    h1d.py                 # inlib histo.
    rroot.py               # read an histo in a root file.
    waxml.py               # write histos at the AIDA XML file format.
    tree.py                # project a ntuple found in the pawdemo.root file
                           # and plot the histo.
    
    polyhedron_vis.py      # visualise a solid/shape boolean operation.
    plotter_window.py      # plot an histo by using softinex graphics and plotting.
                           # A simple viewer is used.
    plotter_vis.py         # same as upper but by using a more advanced "gui viewer".
    cfitsio_hst_vis.py     # visualise an image in a fits file.
    rdirs_vis.py           # random clouds of points in a plot.
    two_cubes_vis.pye      # show the "blender effect" on a coarse grained rearranged
                           # random points.
    
    c3d_vis.py             # create, fill and plot a 3D cloud of 3D random points.
    csv_c3d_vis.py         # read points from cosmo_dc2_rdz_cut.csv, fill and plot a 3D cloud.
    csv_h1d_vis.py         # read points from cosmo_dc2_rdz_cut.csv, fill and plot histos.
    csv_vertices_vis.py    # read points from cosmo_dc2_rdz_cut.csv, and visualize them
                           # with a simple viewer (without a plot).
    csv_vertices_gui_viewer_vis.py # same as upper, but by using a more advanced viewer.
</pre><p>Spark examples: </p><pre class="fragment">    spark_inlib_h1d_vis.py   # inlib histo.
    spark_fits.py            # open spark_test_data.fits and a simple collect.
    spark_fits_ntuple_vis.py # read a TBL in a fits file, do "ntuple projections" with Spark,
                             # and plot with the inexlib/plotter.
    spark_fits_vis.py        # open spark_test_data.fits, do a simple collect, fill and
                             # plot an histo.

 The scripts:                       
    spark_parquet_vis.py
    spark_parquet_radec_vis.py
    spark_parquet_colored_galaxies_vis.py
 uses parquet files not in the distribution.
</pre><p>See the README file on github for instructions on how to build, install and run.</p>
<h1><a class="anchor" id="inexlib_py_swig"></a>
What is wrapped ?</h1>
<p>What is available of inlib/exlib from Python can be seen in the ".i" files given to SWIG. These are available on github at : </p><pre class="fragment">    inexlib_py/inexlib/exlib/exlib/swig
</pre><p>In particular the file nodes.i shows the inlib::sg::nodes declared to SWIG along their "fields" ("sf" for a simple field or "mf" for a multiple field). For example for inlib::sg::cube, what is declared to SWIG is : </p><pre class="fragment">    class cube : public node {
    public:
      virtual node* copy() const;
    public:
      cube();
      virtual ~cube();
      cube(const cube&amp;);
      cube&amp; operator=(const cube&amp;);
    public:  
      sf&lt;float&gt; width;    //simple field for the width of the cube.
      sf&lt;float&gt; height;
      sf&lt;float&gt; depth;
    };
</pre><p> The upper permits, from Python, to do something as : </p><pre class="fragment">    import inlib
    cube = inlib.sg_cube()
    cube.width.value(3)
</pre><p>Note that we do not wrap all the C++ code with SWIG. In general in a C++ class, there are private and protected materials that are for developers and do not need to be seen from Python. The remaining public material can be split in "public/developer" and "public/user". "public/developer" material is for the developer to help classes working together. And the remaining "public/user" fields and methods are the "true" materials that a user want to see; it is the "spirit" for what the class and package had been created. In inexlib_py, we declare to SWIG only the C++ which is "public/user". For the moment, we do not have a nice web reference manual "a la doxygen" for the ".i", then the best is to jump directly in the .i files to have informations. What is here is in general self explanatory and should be already helpfull. </p>
</div></div><!-- contents -->

</body>
</html>
